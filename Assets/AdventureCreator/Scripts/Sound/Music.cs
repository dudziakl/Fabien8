/*
 *
 *	Adventure Creator
 *	by Chris Burton, 2013-2016
 *	
 *	"Music.cs"
 * 
 *	This script handles the playback of Music when played using the 'Sound: Play music' Action.
 * 
 */

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace AC
{

	/**
	 * This script handles the playback of Music when played using the 'Sound: Play music' Action.
	 */
	#if !(UNITY_4_6 || UNITY_4_7 || UNITY_5_0)
	[HelpURL("http://www.adventurecreator.org/scripting-guide/class_a_c_1_1_music.html")]
	#endif
	public class Music : Sound
	{

		private List<QueuedMusic> queuedMusic = new List<QueuedMusic>();
		private MusicCrossfade musicCrossfade;
		private List<QueuedMusic> lastQueuedMusic = new List<QueuedMusic>();
		private List<MusicSample> oldMusicSamples = new List<MusicSample>();
		private int lastTimeSamples;

		// Delay
		private float delayTime;
		private int delayAudioID = -1;
		private float delayFadeTime;
		private bool delayLoop;
		private bool delayResumeIfPlayedBefore;


		private void Awake ()
		{
			musicCrossfade = GetComponentInChildren <MusicCrossfade>();
			playWhilePaused = KickStarter.settingsManager.playMusicWhilePaused;
			surviveSceneChange = true;
			soundType = SoundType.Music;
			Initialise ();

			queuedMusic.Clear ();
			lastQueuedMusic.Clear ();

			if (musicCrossfade == null)
			{
				ACDebug.LogWarning ("The " + gameObject.name + " requires a 'MusicCrossfade' component to be attached as a child component.\r\nOne has been added automatically, but you should update the source prefab.", gameObject);
				GameObject crossfadeOb = new GameObject ("Crossfader");
				crossfadeOb.AddComponent <AudioSource>();
				musicCrossfade = crossfadeOb.AddComponent <MusicCrossfade>();
				crossfadeOb.transform.position = transform.position;
				crossfadeOb.transform.parent = transform;
			}
		}


		public override void _Update ()
		{
			float deltaTime = Time.deltaTime;
			if (KickStarter.stateHandler.gameState == GameState.Paused)
			{
				if (KickStarter.settingsManager.playMusicWhilePaused)
				{
					deltaTime = Time.fixedDeltaTime;
				}
				else
				{
					return;
				}
			}

			if (musicCrossfade)
			{
				musicCrossfade._Update ();
			}

			if (delayAudioID >= 0 && delayTime > 0f)
			{
				delayTime -= deltaTime;

				if (delayTime <= 0f)
				{
					AfterDelay ();
				}
				base._Update ();
			}

			if (queuedMusic.Count > 0 && delayAudioID < 0)
			{
				if (!audioSource.isPlaying)
				{
					ClearMusicSample (queuedMusic[0].trackID);
					queuedMusic.RemoveAt (0);
					if (queuedMusic.Count > 0)
					{
						MusicStorage musicStorage = GetMusic (queuedMusic[0].trackID);
						if (musicStorage != null && musicStorage.audioClip != null)
						{
							int nextTimeSamples = (queuedMusic[0].doResume) ? GetMusicSample (queuedMusic[0].trackID) : 0;

							SetRelativeVolume (musicStorage.relativeVolume);
							Play (musicStorage.audioClip, queuedMusic[0].trackLoop, nextTimeSamples);
						}
					}
				}
				else if (queuedMusic.Count > 1 && delayAudioID < 0)
				{
					QueuedMusic nextMusic = queuedMusic[1];
					if (nextMusic.fadeTime > 0f)
					{
						int nextTimeSamples = (nextMusic.doResume) ? GetMusicSample (nextMusic.trackID) : 0;

						// Need to pre-empt next track
						float thresholdProportion = (audioSource.clip.length - nextMusic.fadeTime) / audioSource.clip.length;
						int thresholdSamples = (int) (thresholdProportion * (float) audioSource.clip.samples);

						if (audioSource.timeSamples > thresholdSamples)
						{
							MusicStorage musicStorage = GetMusic (nextMusic.trackID);
							ClearMusicSample (queuedMusic[0].trackID);
							queuedMusic.RemoveAt (0);

							if (nextMusic.isCrossfade)
							{
								if (musicCrossfade)
								{
									musicCrossfade.FadeOut (audioSource, nextMusic.fadeTime);
								}
								audioSource.clip = musicStorage.audioClip;
								SetRelativeVolume (musicStorage.relativeVolume);
								FadeIn (nextMusic.fadeTime, nextMusic.trackLoop, nextTimeSamples);
							}
							else
							{
								FadeOutThenIn (musicStorage, nextMusic.fadeTime, nextMusic.trackLoop, nextMusic.doResume);
							}
						}
					}
				}
			}

			base._Update ();
		}


		/**
		 * <summary>Plays a new music track</summary>
		 * <param name = "trackID">The ID number of the track, as generated by the MusicStorage class that stores the AudioClip</para>
		 * <param name = "loop">If True, the new music track will be looped</param>
		 * <param name = "isQueued">If True, the music track will be queued until the current track has finished playing</param>
		 * <param name = "fadeTime">The fade-in duration, in seconds</param>
		 * <param name = "resumeIfPlayedBefore">If True, and the track has been both played before and stopped before it finished, the track will be resumed</param>
		 */
		public float Play (int trackID, bool loop, bool isQueued, float fadeTime, bool resumeIfPlayedBefore = false)
		{
			return HandlePlay (trackID, loop, isQueued, fadeTime, false, resumeIfPlayedBefore);
		}


		/**
		 * <summary>Crossfade a new music track</summary>
		 * <param name = "trackID">The ID number of the track, as generated by the MusicStorage class that stores the AudioClip</para>
		 * <param name = "loop">If True, the new music track will be looped</param>
		 * <param name = "isQueued">If True, the music track will be queued until the current track has finished playing</param>
		 * <param name = "fadeTime">The crossfade duration, in seconds</param>
		 * <param name = "resumeIfPlayedBefore">If True, and the track has been both played before and stopped before it finished, the track will be resumed</param>
		 */
		public float Crossfade (int trackID, bool loop, bool isQueued, float fadeTime, bool resumeIfPlayedBefore = false)
		{
			return HandlePlay (trackID, loop, isQueued, fadeTime, true, resumeIfPlayedBefore);
		}


		/**
		 * <summary>Resumes the last-played music queue</summary>
		 * <param name = "fadeTime">The fade-in time in seconds, if greater than zero</param>
		 * <param name = "playFromStart">If True, the music track will play from the beginning</param>
		 */
		public float ResumeLastQueue (float fadeTime, bool playFromStart)
		{
			if (lastQueuedMusic.Count == 0)
			{
				ACDebug.Log ("Can't resume music - nothing in the queue!");
				return 0f;
			}

			bool musicAlreadyPlaying = (queuedMusic.Count > 0) ? true : false;
			if (musicAlreadyPlaying)
			{
				ACDebug.Log ("Can't resume last stopped music, as music is already playing.");
				return 0f;
			}

			queuedMusic.Clear ();
			foreach (QueuedMusic lastQueueMusic in lastQueuedMusic)
			{
				queuedMusic.Add (new QueuedMusic (lastQueueMusic));
			}

			Resume ((playFromStart) ? 0 : lastTimeSamples, fadeTime);
			return fadeTime;
		}


		private float HandlePlay (int trackID, bool loop, bool isQueued, float fadeTime, bool isCrossfade, bool resumeIfPlayedBefore)
		{
			if (musicCrossfade)
			{
				musicCrossfade.Stop ();
			}

			MusicStorage musicStorage = GetMusic (trackID);
			if (musicStorage == null || musicStorage.audioClip == null)
			{
				ACDebug.LogWarning ("Cannot play music - no AudioClip assigned!");
				return 0f;
			}

			if (isQueued && queuedMusic.Count > 0)
			{
				queuedMusic.Add (new QueuedMusic (trackID, loop, fadeTime, isCrossfade, resumeIfPlayedBefore));
				return 0f;
			}
			else
			{
				if (queuedMusic.Count > 0 && queuedMusic[0].trackID == trackID)
				{
					// Already playing, ignore
					return 0f;
				}
				
				/*if (queuedMusic.Count > 0 && queuedMusic[0].trackLoop)
				{
					// Looping current, ignore
					return 0f;
				}*/

				// End other music objects
				Sound[] sounds = FindObjectsOfType (typeof (Sound)) as Sound[];
				foreach (Sound sound in sounds)
				{
					sound.EndOldMusic (this);
				}
				
				bool musicAlreadyPlaying = (queuedMusic.Count > 0) ? true : false;
				if (musicAlreadyPlaying)
				{
					StoreMusicSampleByIndex (0);
				}

				int newTrackTimeSamples = (resumeIfPlayedBefore) ? GetMusicSample (trackID) : 0;
				
				queuedMusic.Clear ();
				queuedMusic.Add (new QueuedMusic (trackID, loop));

				if (musicAlreadyPlaying)
				{
					if (fadeTime > 0f)
					{
						if (isCrossfade)
						{
							if (musicCrossfade)
							{
								musicCrossfade.FadeOut (audioSource, fadeTime);
							}
							audioSource.clip = musicStorage.audioClip;
							FadeIn (fadeTime, loop, newTrackTimeSamples);
							return fadeTime;
						}
						else
						{
							FadeOutThenIn (musicStorage, fadeTime, loop, resumeIfPlayedBefore);
							return (fadeTime * 2f);
						}
					}
					else
					{
						Stop ();
						SetRelativeVolume (musicStorage.relativeVolume);
						Play (musicStorage.audioClip, loop, newTrackTimeSamples);
						return 0f;
					}
				}
				else
				{
					SetRelativeVolume (musicStorage.relativeVolume);
					
					if (fadeTime > 0f)
					{
						audioSource.clip = musicStorage.audioClip;
						FadeIn (fadeTime, loop, newTrackTimeSamples);
						return fadeTime;
					}
					else
					{
						Play (musicStorage.audioClip, loop, newTrackTimeSamples);
						return 0f;
					}
				}
			}
		}


		/**
		 * <summary>Stops the currently-playing music track, and cancels all those in the queue.</summary>
		 * <param name = "fadeTime">The time over which to stop the music</param>
		 * <param name = "storeCurrentIndex">If the current time index of the music will be stored so that it can be resumed later</param>
		 * <returns>The fade time necessary to stop the music</returns>
		 */
		public float StopAll (float fadeTime, bool storeCurrentIndex = true)
		{
			if (queuedMusic.Count == 0 && audioSource != null && !audioSource.isPlaying &&
				(musicCrossfade == null || !musicCrossfade.IsPlaying ()))
			{
				return 0f;
			}

			return ForceStopAll (fadeTime, storeCurrentIndex);
		}


		private float ForceStopAll (float fadeTime, bool storeCurrentIndex = true)
		{
			if (fadeTime == 0f && musicCrossfade)
			{
				musicCrossfade.Stop ();
			}

			if (storeCurrentIndex)
			{
				StoreMusicSampleByIndex (0);
			}

			delayAudioID = -1;

			ClearMusicQueue ();

			if (fadeTime > 0f && audioSource.isPlaying)
			{
				FadeOut (fadeTime);
				return fadeTime;
			}
			else
			{
				Stop ();
			}
			return 0f;
		}


		private void ClearMusicQueue ()
		{
			lastTimeSamples = 0;
			if (queuedMusic != null && queuedMusic.Count > 0)
			{
				MusicStorage musicStorage = GetMusic (queuedMusic[0].trackID);
				if (musicStorage != null && musicStorage.audioClip != null && audioSource.clip == musicStorage.audioClip && audioSource.isPlaying)
				{
					lastTimeSamples = audioSource.timeSamples;
				}
			}

			lastQueuedMusic.Clear ();
			foreach (QueuedMusic queueMusic in queuedMusic)
			{
				lastQueuedMusic.Add (new QueuedMusic (queueMusic));
			}
			queuedMusic.Clear ();
		}


		private void FadeOutThenIn (MusicStorage musicStorage, float fadeTime, bool loop, bool resumeIfPlayedBefore)
		{
			FadeOut (fadeTime);

			delayTime = fadeTime;
			delayAudioID = musicStorage.ID;
			delayFadeTime = fadeTime;
			delayLoop = loop;
			delayResumeIfPlayedBefore = resumeIfPlayedBefore;
		}


		private void AfterDelay ()
		{
			if (delayAudioID >= 0)
			{
				delayTime = 0f;

				MusicStorage musicStorage = GetMusic (delayAudioID);
				if (musicStorage != null)
				{
					int timeSamples = (delayResumeIfPlayedBefore) ? GetMusicSample (delayAudioID) : 0;

					audioSource.clip = musicStorage.audioClip;
					SetRelativeVolume (musicStorage.relativeVolume);
					FadeIn (delayFadeTime, delayLoop, timeSamples);
				}
			}

			delayAudioID = -1;
		}


		private void Resume (int _timeSamples, float fadeTime = 0f)
		{
			if (queuedMusic.Count > 0)
			{
				MusicStorage musicStorage = GetMusic (queuedMusic[0].trackID);
				if (musicStorage != null && musicStorage.audioClip != null)
				{
					audioSource.clip = musicStorage.audioClip;
					SetRelativeVolume (musicStorage.relativeVolume);
					PlayAtPoint (queuedMusic[0].trackLoop, _timeSamples);

					if (fadeTime > 0f)
					{
						FadeIn (fadeTime, queuedMusic[0].trackLoop, _timeSamples);
					}
				}
			}
		}


		/**
		 * <summary>Updates a MainData class with its own variables that need saving.</summary>
		 * <param name = "mainData">The original MainData class</param>
		 * <returns>The updated MainData class</returns>
		 */
		public MainData SaveMainData (MainData mainData)
		{
			StringBuilder lastMusicString = new StringBuilder ();
			for (int i=0; i<lastQueuedMusic.Count; i++)
			{
				lastMusicString.Append (lastQueuedMusic[i].trackID.ToString ());
				lastMusicString.Append (SaveSystem.colon);
				lastMusicString.Append ((lastQueuedMusic[i].trackLoop) ? "1" : "0");
				lastMusicString.Append (SaveSystem.colon);
				lastMusicString.Append (lastQueuedMusic[i].fadeTime);
				lastMusicString.Append (SaveSystem.colon);
				lastMusicString.Append ((lastQueuedMusic[i].isCrossfade) ? "1" : "0");
			
				if (i < (lastQueuedMusic.Count-1))
				{
					lastMusicString.Append (SaveSystem.pipe);
				}
			}

			mainData.lastMusicQueueData = lastMusicString.ToString ();

			StringBuilder musicString = new StringBuilder ();
			for (int i=0; i<queuedMusic.Count; i++)
			{
				musicString.Append (queuedMusic[i].trackID.ToString ());
				musicString.Append (SaveSystem.colon);
				musicString.Append ((queuedMusic[i].trackLoop) ? "1" : "0");
				musicString.Append (SaveSystem.colon);
				musicString.Append (queuedMusic[i].fadeTime);
				musicString.Append (SaveSystem.colon);
				musicString.Append ((queuedMusic[i].isCrossfade) ? "1" : "0");
			
				if (i < (queuedMusic.Count-1))
				{
					musicString.Append (SaveSystem.pipe);
				}
			}
			mainData.musicQueueData = musicString.ToString ();

			mainData.musicTimeSamples = 0;
			mainData.lastMusicTimeSamples = lastTimeSamples;

			if (queuedMusic.Count > 0)
			{
				MusicStorage musicStorage = GetMusic (queuedMusic[0].trackID);
				if (musicStorage != null && musicStorage.audioClip != null && audioSource.clip == musicStorage.audioClip && audioSource.isPlaying)
				{
					mainData.musicTimeSamples = audioSource.timeSamples;
				}
			}

			StringBuilder oldTimeSamplesString = new StringBuilder ();
			for (int i=0; i<oldMusicSamples.Count; i++)
			{
				oldTimeSamplesString.Append (oldMusicSamples[i].trackID.ToString ());
				oldTimeSamplesString.Append (SaveSystem.colon);
				oldTimeSamplesString.Append (oldMusicSamples[i].timeSample.ToString ());

				if (i < (oldMusicSamples.Count-1))
				{
					oldTimeSamplesString.Append (SaveSystem.pipe);
				}
			}
			mainData.oldMusicTimeSamples = oldTimeSamplesString.ToString ();

			return mainData;
		}
		
		
		/**
		 * <summary>Updates its own variables from a MainData class.</summary>
		 * <param name = "mainData">The MainData class to load from</param>
		 */
		public void LoadMainData (MainData mainData)
		{
			ForceStopAll (0f, false);

			if (mainData.oldMusicTimeSamples != null && mainData.oldMusicTimeSamples.Length > 0)
			{
				oldMusicSamples.Clear ();
				string[] oldArray = mainData.oldMusicTimeSamples.Split (SaveSystem.pipe[0]);
				foreach (string chunk in oldArray)
				{
					string[] chunkData = chunk.Split (SaveSystem.colon[0]);

					// ID
					int _id = 0;
					int.TryParse (chunkData[0], out _id);

					// TimeSample
					int _timeSamples = 0;
					int.TryParse (chunkData[1], out _timeSamples);

					oldMusicSamples.Add (new MusicSample (_id, _timeSamples));
				}
			}

			lastTimeSamples = mainData.lastMusicTimeSamples;

			if (mainData.lastMusicQueueData != null && mainData.lastMusicQueueData.Length > 0)
			{
				lastQueuedMusic.Clear ();
				string[] queueArray = mainData.lastMusicQueueData.Split (SaveSystem.pipe[0]);
				foreach (string chunk in queueArray)
				{
					string[] chunkData = chunk.Split (SaveSystem.colon[0]);

					// ID
					int _id = 0;
					int.TryParse (chunkData[0], out _id);

					// Loop
					int _loop = 0;
					int.TryParse (chunkData[1], out _loop);
					bool loopBool = (_loop == 1) ? true : false;

					// FadeTime
					float _fadeTime = 0f;
					float.TryParse (chunkData[2], out _fadeTime);

					// Crossfade
					int _crossfade = 0;
					int.TryParse (chunkData[3], out _crossfade);
					bool crossfadeBool = (_crossfade == 1) ? true : false;

					lastQueuedMusic.Add (new QueuedMusic (_id, loopBool, _fadeTime, crossfadeBool));
				}
			}

			if (mainData.musicQueueData != null && mainData.musicQueueData.Length > 0)
			{
				string[] queueArray = mainData.musicQueueData.Split (SaveSystem.pipe[0]);
				foreach (string chunk in queueArray)
				{
					string[] chunkData = chunk.Split (SaveSystem.colon[0]);

					// ID
					int _id = 0;
					int.TryParse (chunkData[0], out _id);

					// Loop
					int _loop = 0;
					int.TryParse (chunkData[1], out _loop);
					bool loopBool = (_loop == 1) ? true : false;

					// FadeTime
					float _fadeTime = 0f;
					float.TryParse (chunkData[2], out _fadeTime);

					// Crossfade
					int _crossfade = 0;
					int.TryParse (chunkData[3], out _crossfade);
					bool crossfadeBool = (_crossfade == 1) ? true : false;

					queuedMusic.Add (new QueuedMusic (_id, loopBool, _fadeTime, crossfadeBool));
				}

				Resume (mainData.musicTimeSamples);
			}
		}


		private MusicStorage GetMusic (int ID)
		{
			foreach (MusicStorage musicStorage in KickStarter.settingsManager.musicStorages)
			{
				if (musicStorage.ID == ID)
				{
					return musicStorage;
				}
			}
			return null;
		}


		private void SetRelativeVolume (float _relativeVolume)
		{
			relativeVolume = _relativeVolume;
			SetMaxVolume ();
		}


		private void StoreMusicSampleByIndex (int index)
		{
			if (queuedMusic != null && queuedMusic.Count > index)
			{
				int trackID = queuedMusic[index].trackID;
				MusicStorage musicStorage = GetMusic (trackID);
				if (musicStorage != null && musicStorage.audioClip != null && audioSource.clip == musicStorage.audioClip && audioSource.isPlaying)
				{
					SetMusicSample (trackID, audioSource.timeSamples);
				}
			}
		}
		

		private int GetMusicSample (int trackID)
		{
			foreach (MusicSample musicSample in oldMusicSamples)
			{
				if (musicSample.trackID == trackID)
				{
					return musicSample.timeSample;
				}
			}
			return 0;
		}


		private void ClearMusicSample (int trackID)
		{
			foreach (MusicSample musicSample in oldMusicSamples)
			{
				if (musicSample.trackID == trackID)
				{
					oldMusicSamples.Remove (musicSample);
					return;
				}
			}
		}


		private void SetMusicSample (int trackID, int timeSample)
		{
			ClearMusicSample (trackID);

			MusicSample newMusicSample = new MusicSample (trackID, timeSample);
			oldMusicSamples.Add (newMusicSample);
		}


		private struct QueuedMusic
		{

			public int trackID;
			public bool trackLoop;
			public float fadeTime;
			public bool isCrossfade;
			public bool doResume;


			public QueuedMusic (int _trackID, bool _trackLoop, float _fadeTime = 0f, bool _isCrossfade = false, bool _doResume = false)
			{
				trackID = _trackID;
				trackLoop = _trackLoop;
				fadeTime = _fadeTime;
				doResume = _doResume;

				if (fadeTime > 0f)
				{
					isCrossfade = _isCrossfade;
				}
				else
				{
					isCrossfade = false;
				}
			}


			public QueuedMusic (QueuedMusic _queueMusic)
			{
				trackID = _queueMusic.trackID;
				trackLoop = _queueMusic.trackLoop;
				fadeTime = _queueMusic.fadeTime;
				isCrossfade = _queueMusic.isCrossfade;
				doResume = false;
			}

		}


		private struct MusicSample
		{

			public int trackID;
			public int timeSample;


			public MusicSample (int _trackID, int _timeSample)
			{
				trackID = _trackID;
				timeSample = _timeSample;
			}

		}

	}

}